# Java基础知识

## 1. 概览

### 1.1. 关键笔记

🥑String、StringBuffer、StringBuilder的区别

🥑接口和抽象类的区别

🥑Java常见的异常类有哪些

🥑说一说Java面向对象三大特性

🥑说一说你对Java多态的理解

🥑重写和重载的区别

🥑final关键字有什么作用

🥑java中==和EQUALS的区别

🥑Java的集合类有哪些，那些是线程安全的，那些是线程不安全的

🥑ArrayList和Array有什么区别？ArrayList和LinkedList的区别是什么？

🥑ArrayList的扩容机制

🥑Java中的HashMap了解吗？HashMap的底层实现是什么？

🥑解决Hash冲突的方法有哪些？HashMap是如何解决hash冲突的

🥑HashMap的put方法流程

🥑HashMap的扩容机制

🥑HashMap为什么是线程不安全的？如何实现线程安全

🥑concurrentHashMap如何保证线程安全

🥑HashMap和ConcurrentHashMap的区别

🥑HashSet和HashMap的区别

🥑HashMap和HashTable的区别

## 2. 面相对象

### 2.1. 面向对象三大特性

1. 封装（Encapsulation）
2. 继承（Inheritance）
3. 多态（Polymorphism）

### 2.2. 类和对象

**类** = **属性 + 方法** + 构造方法 + 静态成员 + 访问控制 + ...（模板化定义）

**对象** = **实例（instance）**= 实例变量（状态） + 对类中方法的引用，实例方法（行为） + 对象头（JVM 管理信息）

### 2.3. 对象的创建和使用

#### 2.3.1. 对象 & 引用

**引用**：引用本质上是一个 **变量**，这个变量中保存了 **对象的地址**，这个地址就是Java对象在堆内存中的位置

**对象**：对象在堆内存中，`new` 出来的

> Java中无法直接操作堆内存，只能通过引用来访问堆内存
>
> 两种访问方式：
> - 读取：引用.变量名 `s1.name; s1.age = 18;`
> - 修改：引用.变量名 = 新值 `s1.name = "zhangsan"; s1.age = 22;`

#####  2.3.1.1. new 运算符

1. **分配内存**：在 **堆内存** 中给对象分配一块连续的内存(所有使用 `new` 运算符创建的对象都存储在堆中)
2. **初始化对象**：
   - 设置对象的对象头（存储类指针、GC信息、锁状态等元数据）
   - 初始化对象的实例变量（成员变量），赋予默认值（如 `int` 初始化为0，引用初始化为 `null`）
   - 调用对象的构造方法（`<init>` 方法），进一步初始化对象状态
3. **返回对象引用**：将堆内存中对象的地址赋值给 **引用变量**（存储在栈帧或堆中的其他对象内）

##### 2.3.1.2. 空指针异常

当引用为空时（`引用 = null`），表示引用不再指向对象

访问引用的成员变量或方法，编译可以通过，但运行时会出现异常：`NullPointerException` 空指针异常

如果没有任何引用指向某一个对象，该对象最终会被当做垃圾，被垃圾回收器 `GC` 回收

#### 2.3.2. 🤔对象的内存分析

##### 2.3.2.1. 实例变量

**实例变量** 存储在 JVM堆内存 的 **Java对象** 内部

- **实例变量**（Instance Variables）是类的成员变量，定义在类中但不在任何方法内 
  - 实例变量在对象中，需要用 `引用.实例变量名` 来访问，不可以直接用 `类名.实例变量名` 访问，只有先有对象才有实例变量
- **特点**：  
  - 每个对象拥有独立的实例变量副本
  - 生命周期与对象一致，对象被垃圾回收时，其实例变量占用的内存才会释放
  - 可以是基本类型（如`int`、`double`）或引用类型（如`String`、自定义类）
- **存储方式**：
  - **基本类型**：直接存储值
    - 例如：`int age = 25;` → 在实例数据区占用4字节
  - **引用类型**：存储指向堆中另一个对象的地址（引用）
    - 例如：`String name = "Alice";` → 存储的是指向堆中`String`对象的引用（通常4字节或8字节，取决于JVM位数）

```
+-----------------------+
|      对象头（16字节）     |
+-----------------------+
| name（引用，4字节）       | → 指向堆中的String对象"Alice"，存的是一个地址
| age（int，4字节）         | → 直接存储25
+-----------------------+
| 对齐填充（可选）          |
+-----------------------+
```

**变量对比**：

| **变量类型** | **存储位置**       | **生命周期**               | **示例**              |
|--------------|--------------------|--------------------------|-----------------------|
| 实例变量      | 堆中的对象内部      | 与对象共存亡               | `class A { int x; }`  |
| 局部变量      | 虚拟机栈的栈帧中    | 方法执行期间存在           | `void foo() { int y; }` |
| 静态变量      | 元空间（方法区）    | 与类共存亡（类卸载时释放）   | `static int z;`       |

##### 2.3.2.2. 实例方法

**实例方法** 是与对象关联的方法，需要通过对象实例调用（如 `obj.method()`）

- 特点：
  - 每个实例方法隐含一个 `this` 引用，指向调用该方法的对象
  - 方法的代码逻辑是**共享的**，所有对象实例共享同一份方法字节码
- 存储：
  - **方法代码（字节码）**：
    - **元空间** 中存储所有方法的 **字节码** 和 **元数据**（方法名、参数类型、返回类型、访问修饰符、异常表等）
    - 所有对象实例共享同一份方法代码，无需重复存储
  - 方法执行时的 **数据**：方法调用时的局部变量、操作数栈等存储在 **虚拟机栈的栈帧** 中
- 执行过程
  1. **创建栈帧**：在调用线程的**虚拟机栈**中压入一个栈帧，存储方法的局部变量、操作数栈等信息
  2. **传递 `this` 引用**：将调用方法的对象地址（即 `this`）作为隐含参数传递给栈帧的局部变量表
  3. **执行字节码**：从元空间加载方法字节码，在操作数栈中执行指令
  4. **方法返回**：栈帧弹出，释放内存。

**实例方法与静态方法的存储对比**

| **对比项**       | **实例方法**                     | **静态方法**                     |
|------------------|----------------------------------|----------------------------------|
| **存储位置**      | 元空间（方法代码）                | 元空间（方法代码）                |
| **调用方式**      | 需对象实例（隐含 `this`）         | 直接通过类名调用（无 `this`）     |
| **局部变量表**    | 包含 `this` 引用                  | 不包含 `this`                    |
| **访问权限**      | 可访问实例变量和静态变量           | 只能访问静态变量                  |

#### 2.3.3. 🤔相关JVM内存区域

**JVM内存核心区域划分**

* **堆**（Heap）
* **虚拟机栈**（VM Stack）
* **本地方法栈**（Native Method Stack）
* **程序计数器**（Program Counter Register, The PC Register）
* **运行时常量池** (Run-Time Constant Pool)
* **方法区**（Method Area）【规范，由元空间实现】

JVM中有GC机制，垃圾回收机制，java是自动垃圾回收（自动垃圾回收主要针对的是堆区，堆是动态分配对象内存的区域，对象生命周期不确定，是GC的核心目标）

对象的内存分析主要涉及 **堆**、**方法区（元空间）**、**虚拟机栈**

##### 2.3.3.1. 方法区 & 元空间 & 永久代

**方法区**（Method Area） 是 JVM 运行时的一块逻辑区域（JVM规范中的叫法），主要存储类的 **元数据（Metadata）**，包括：

* 已加载的类信息（Class Metadata）
* 运行时常量池（Runtime Constant Pool）
* 静态变量（Static Variables）
* JIT 编译后的代码（JIT-compiled Code）

- 特点
  - 方法区是逻辑概念，具体实现方式依赖 JVM 版本
  * 它是所有线程共享的
  * 方法区可以在垃圾回收（GC）过程中回收废弃的类信息
  
> JVM是一套规范，各个厂家都可以根据这个规范去实现具体的Java虚拟机

**元空间**（Metaspace） 和 **永久代**（Permanent Generation，PermGen） 是对方法区的实现

* 永久代: ≤Java7
  * 大小固定，容易导致 OOM（OutOfMemoryError: PermGen space）
* 元空间: ≥Java8
  * 大小可动态调整，不会出现 OOM
  * **不使用堆内存**，而是使用 **本地内存（Native Memory）**

##### 2.3.3.2. 虚拟机栈（VM Stack）

虚拟机栈是JVM为 **每个线程** 分配的私有内存区域，用于支持方法调用和执行

* **线程私有**：每个线程在创建时都会生成一个独立的虚拟机栈。

* **栈结构**：采用后进先出（LIFO） 的数据结构，存储方法调用的 **栈帧（Frame）**。

* **生命周期**：与线程共存亡，线程结束时栈内存自动释放

**栈帧** 的结构：

```
+-----------------------+
|     **局部变量表**       | → 存储方法的参数和局部变量
+-----------------------+
|     **操作数栈**         | → 执行字节码指令的临时工作区
+-----------------------+
|     **动态链接**         | → 指向方法区中方法的符号引用
+-----------------------+
|     **方法返回地址**      | → 记录方法执行完毕后应返回的位置
+-----------------------+
|     附加信息（可选）      | → 如调试信息、异常表等
+-----------------------+
```

##### 2.3.3.3. 堆（Heap）

**Java对象在堆内存中的结构**

```
+-----------------------+
|      对象头（Header）     | → 存储类指针、GC标记、锁状态等元数据
+-----------------------+
|   实例数据（Instance Data） | → 存储所有实例变量（核心部分）
+-----------------------+
|   对齐填充（Padding）      | → 确保对象内存对齐（由JVM按需添加）
+-----------------------+
```

#### 2.3.4. 方法调用时数据的传递

在方法调用时，参数传递始终是 **按值传递（Pass by Value）**，无论参数是 **基本类型** 还是 **对象引用**，传递的都是当前变量 **值** 的 **副本** ❗

- **基本数据类型** 副本是原始值的独立拷贝，方法内修改副本不影响原始变量

  ```java
  public class Test {
      public static void main(String[] args) {
          int a = 10;
          change(a);
          // 相当于 int b = a;
          // change(b); 复制一个 a 传给change
          System.out.println("main: " + a);
      }
      public static void change(int a) {
          a = 20;
          System.out.println("change: " + a);
      }
  }
  ```
  输出结果：
  ```
  main: 10
  change: 20
  ```

- **引用数据类型** 副本是原引用地址的拷贝，传递的是 **对象引用** 的值，而引用的值是一个 **地址**，方法内通过副本修改对象状态会影响原对象，但重新赋值副本（如指向新对象）不影响原引用

  ```java
  public class Test {
      public static void main(String[] args) {
          User a = new User();
          a.age = 10;
          change(a);
          System.out.println("main: " + a.age);
      }
      public static void change(User a) {
          a.age = 20;
          System.out.println("change: " + a.age);
      }
  }
  ```

